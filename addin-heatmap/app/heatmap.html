<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>FW Heatmap</title>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"/>
  <script src="https://cdn.jsdelivr.net/npm/@geotab/sdk@latest/dist/sdk.min.js"></script>
  <style>
    #map { height: 60vh; min-height: 320px; }
    .sidebar { padding: 1em; background: #f8f9fa; border-radius: 8px; box-shadow: 0 2px 8px #ddd; }
    .legend span { margin-right: 1em; }
    .ev-marker { color: #00bfff; }
    .low-battery-marker { color: #ff3333; }
    .charging-marker { color: #33ff33;}
    .fault-critical { color: #dc3545; }
    .fault-warning { color: #ffc107; }
    .fault-info { color: #0dcaf0; }
    .leaflet-popup-content { min-width: 180px; }
    .summary-list li { margin-bottom: 0.5em; }
    @media (max-width: 768px) {
      #map { height: 35vh; }
    }
  </style>
</head>
<body>
  <div class="container-fluid">
    <div class="row mb-2">
      <div class="col-md-12">
        <h2>FW Heatmap</h2>
        <div class="sidebar d-flex flex-wrap gap-2 align-items-center mb-2">
          <input type="date" id="startDate"/><input type="date" id="endDate"/>
          <select id="deviceSelect"><option>All Devices</option></select>
          <select id="evFilter">
            <option value="all">All</option>
            <option value="ev">EV Only</option>
            <option value="ice">ICE Only</option>
          </select>
          <select id="dataType">
            <option value="heatmap">Heatmap</option>
            <option value="battery">Battery Level</option>
            <option value="charging">Charging Events</option>
            <option value="faults">Faults</option>
            <option value="efficiency">Route Efficiency</option>
          </select>
          <button id="refreshBtn" class="btn btn-primary btn-sm" aria-label="Refresh Data">Refresh</button>
          <button id="exportBtn" class="btn btn-outline-secondary btn-sm" aria-label="Export CSV">Export CSV</button>
          <button id="exportMapBtn" class="btn btn-outline-secondary btn-sm" aria-label="Export Map as Image">Export Map</button>
        </div>
        <div class="legend">
          <strong>Legend:</strong>
          <span style="background: linear-gradient(to right, #00f, #ff0, #f00); padding: 0.3em 1em; border-radius: 6px;">Heatmap Intensity</span>
          <span style="color: #00bfff;">● EV Battery Point</span>
          <span style="color: #ff3333;">● Low Battery Event</span>
          <span style="color: #33ff33;">⚡ Charge Location</span>
          <span style="color: #dc3545;">● Critical Fault</span>
          <span style="color: #ffc107;">● Warning Fault</span>
          <span style="color: #0dcaf0;">● Info Fault</span>
        </div>
      </div>
    </div>
    <div class="row">
      <div class="col-md-8">
        <div id="map"></div>
      </div>
      <div class="col-md-4">
        <div class="sidebar">
          <h4>Summary</h4>
          <ul class="summary-list" id="summaryStats">
            <li>Total charges: <span id="totalCharges">-</span></li>
            <li>Avg battery: <span id="avgBattery">-</span></li>
            <li>Low battery events: <span id="lowBatteryCount">-</span></li>
            <li>Faults: <span id="faultCount">-</span></li>
            <li>Critical Faults: <span id="faultCriticalCount">-</span></li>
            <li>Charging recommendations: <span id="chargingRecommendations">-</span></li>
            <li>EV vs ICE stats: <span id="evIceStats">-</span></li>
          </ul>
          <div id="faultList" style="max-height:150px;overflow-y:auto;"></div>
        </div>
      </div>
    </div>
  </div>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <script>
    // Rules:
    // 1. Always use Geotab SDK for data (no hardcoded demo data).
    // 2. Apply filters for date/device/EV/ICE.
    // 3. Show overlays for battery, charging, faults, heatmap.
    // 4. Ensure UI is responsive and accessible.
    // 5. Provide export options for CSV and map image.
    // 6. All code modular and commented for maintainability.

    let map = L.map('map').setView([0, 0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '© OpenStreetMap contributors' }).addTo(map);

    // Geotab SDK instance
    const sdk = new geotab.sdk.API();

    // Data containers
    let devices = [];
    let batteryEvents = [];
    let chargingEvents = [];
    let faults = [];

    // Utility: Get date range from UI
    function getDateRange() {
      let start = document.getElementById('startDate').value;
      let end = document.getElementById('endDate').value;
      // Default: Last 7 days if blank
      if (!start || !end) {
        let now = new Date();
        let past = new Date(now); past.setDate(now.getDate() - 7);
        start = past.toISOString().substring(0, 10);
        end = now.toISOString().substring(0, 10);
        document.getElementById('startDate').value = start;
        document.getElementById('endDate').value = end;
      }
      return { start, end };
    }

    // Utility: Get device filter
    function getDeviceFilter() {
      let sel = document.getElementById('deviceSelect');
      return sel.value === "all" ? null : sel.value;
    }

    // Utility: Get EV/ICE filter
    function getEVFilter() {
      let sel = document.getElementById('evFilter');
      return sel.value;
    }

    // Utility: Get data type to display
    function getDataType() {
      let sel = document.getElementById('dataType');
      return sel.value;
    }

    // Authenticate and fetch all data
    async function authenticate() {
      try {
        await fetchDevices();
        await fetchBatteryEvents();
        await fetchChargingEvents();
        await fetchFaults();
        renderDeviceOptions();
        filterAndRender();
      } catch (e) {
        alert("Error loading data from Geotab: " + e.message);
      }
    }

    // Fetch all devices
    async function fetchDevices() {
      devices = await sdk.call("Get", { typeName: "Device", search: {} });
    }

    // Fetch EV battery events (uses diagnostic "BatteryLevel")
    async function fetchBatteryEvents() {
      let diagnostics = await sdk.call("Get", { typeName: "Diagnostic", search: { code: "BatteryLevel" } });
      let diagnosticId = diagnostics[0] ? diagnostics[0].id : null;
      if (!diagnosticId) { batteryEvents = []; return; }
      let { start, end } = getDateRange();
      let statusData = await sdk.call("Get", {
        typeName: "StatusData",
        search: {
          diagnosticSearch: { id: diagnosticId },
          fromDate: start,
          toDate: end
        }
      });
      batteryEvents = statusData.map(sd => ({
        lat: sd.latitude,
        lng: sd.longitude,
        device: devices.find(d => d.id === sd.device.id)?.name || sd.device.id,
        deviceId: sd.device.id,
        level: Number(sd.data),
        time: sd.dateTime,
        low: Number(sd.data) < 20 // Threshold for 'low battery'
      })).filter(e => e.lat && e.lng);
    }

    // Fetch charging events (uses diagnostic "ChargingEvent")
    async function fetchChargingEvents() {
      let diagnostics = await sdk.call("Get", { typeName: "Diagnostic", search: { code: "ChargingEvent" } });
      let diagnosticId = diagnostics[0] ? diagnostics[0].id : null;
      if (!diagnosticId) { chargingEvents = []; return; }
      let { start, end } = getDateRange();
      let statusData = await sdk.call("Get", {
        typeName: "StatusData",
        search: {
          diagnosticSearch: { id: diagnosticId },
          fromDate: start,
          toDate: end
        }
      });
      chargingEvents = statusData.map(sd => ({
        lat: sd.latitude,
        lng: sd.longitude,
        device: devices.find(d => d.id === sd.device.id)?.name || sd.device.id,
        deviceId: sd.device.id,
        time: sd.dateTime,
        station: sd.locationName || "Unknown"
      })).filter(e => e.lat && e.lng);
    }

    // Fetch vehicle faults (DTCs)
    async function fetchFaults() {
      let { start, end } = getDateRange();
      let faultData = await sdk.call("Get", {
        typeName: "FaultData",
        search: {
          fromDate: start,
          toDate: end
        }
      });
      faults = faultData.map(f => ({
        lat: f.latitude,
        lng: f.longitude,
        device: devices.find(d => d.id === f.device.id)?.name || f.device.id,
        deviceId: f.device.id,
        code: f.diagnostic.code,
        description: f.diagnostic.description || "",
        severity: f.severity || "info",
        time: f.dateTime
      })).filter(f => f.lat && f.lng);
    }

    // Render device selection dropdown
    function renderDeviceOptions() {
      const sel = document.getElementById('deviceSelect');
      sel.innerHTML = '<option value="all">All Devices</option>';
      devices.forEach(d => {
        let type = d.fuelType === "Electric" ? "ev" : "ice";
        sel.innerHTML += `<option value="${d.id}">${d.name} (${type.toUpperCase()})</option>`;
      });
    }

    // Apply all user filters and render overlays
    function filterAndRender() {
      const deviceId = getDeviceFilter();
      const evFilter = getEVFilter();
      // Device filtering
      let deviceIds = devices
        .filter(d => {
          if (deviceId && d.id !== deviceId) return false;
          if (evFilter === "ev" && d.fuelType !== "Electric") return false;
          if (evFilter === "ice" && d.fuelType === "Electric") return false;
          return true;
        })
        .map(d => d.id);

      // Filter events by device
      let filteredBattery = batteryEvents.filter(e => deviceIds.includes(e.deviceId));
      let filteredCharging = chargingEvents.filter(e => deviceIds.includes(e.deviceId));
      let filteredFaults = faults.filter(f => deviceIds.includes(f.deviceId));

      renderMap(filteredBattery, filteredCharging, filteredFaults);
      renderSummary(filteredBattery, filteredCharging, filteredFaults, deviceIds);
    }

    // Render all overlays on the map
    function renderMap(filteredBattery, filteredCharging, filteredFaults) {
      // Remove old markers
      map.eachLayer(layer => { if (layer instanceof L.CircleMarker || layer instanceof L.Marker) map.removeLayer(layer); });
      // Battery events
      filteredBattery.forEach(e => {
        const color = e.low ? '#ff3333' : '#00bfff';
        L.circleMarker([e.lat, e.lng], { color, radius: 9, fillOpacity: 0.8 })
          .addTo(map)
          .bindPopup(
            `<b>${e.device}</b><br>Battery: ${e.level}%<br>Time: ${e.time}${e.low ? '<br><span style="color:red">Low Battery</span>' : ''}`
          );
      });
      // Charging events
      filteredCharging.forEach(e => {
        L.marker([e.lat, e.lng], { icon: L.divIcon({className: '', html: '<span style="color:#33ff33;font-size:1.5em;">⚡</span>'}) })
          .addTo(map)
          .bindPopup(`<b>${e.device}</b><br>Charged at: ${e.station}<br>Time: ${e.time}`);
      });
      // Faults
      filteredFaults.forEach(f => {
        let color = f.severity === 'critical' ? '#dc3545' : (f.severity === 'warning' ? '#ffc107' : '#0dcaf0');
        L.circleMarker([f.lat, f.lng], { color, radius: 10, fillOpacity: 0.7 })
          .addTo(map)
          .bindPopup(
            `<b>${f.device}</b><br>Fault: ${f.code}<br>${f.description}<br>Severity: <span style="color:${color}">${f.severity.toUpperCase()}</span><br>Time: ${f.time}`
          );
      });
      // Fit map to markers if any
      const allCoords = [
        ...filteredBattery.map(e => [e.lat, e.lng]),
        ...filteredCharging.map(e => [e.lat, e.lng]),
        ...filteredFaults.map(f => [f.lat, f.lng])
      ];
      if (allCoords.length) map.fitBounds(allCoords);
    }

    // Render summary statistics and fault list
    function renderSummary(filteredBattery, filteredCharging, filteredFaults, deviceIds) {
      // Summary panel
      document.getElementById('totalCharges').textContent = filteredCharging.length;
      document.getElementById('avgBattery').textContent = (
        filteredBattery.reduce((a, b) => a + Number(b.level), 0) / (filteredBattery.length || 1)
      ).toFixed(1) + '%';
      document.getElementById('lowBatteryCount').textContent = filteredBattery.filter(e => e.low).length;
      document.getElementById('faultCount').textContent = filteredFaults.length;
      document.getElementById('faultCriticalCount').textContent = filteredFaults.filter(f => f.severity === 'critical').length;
      let evCount = devices.filter(d => deviceIds.includes(d.id) && d.fuelType === "Electric").length;
      let iceCount = devices.filter(d => deviceIds.includes(d.id) && d.fuelType !== "Electric").length;
      document.getElementById('evIceStats').textContent = `EV: ${evCount} | ICE: ${iceCount}`;
      document.getElementById('chargingRecommendations').textContent =
        filteredBattery.filter(e => e.low).length > 0 ? 'Recommend charging at next opportunity.' : 'All EVs above threshold.';
      // Fault list
      let faultsList = filteredFaults.map(f =>
        `<div><b>${f.device}</b> [${f.code}] <span style="color:${f.severity === 'critical' ? '#dc3545' : (f.severity === 'warning' ? '#ffc107' : '#0dcaf0')}">${f.severity.toUpperCase()}</span><br>${f.description} (${f.time})</div>`
      ).join('');
      document.getElementById('faultList').innerHTML = faultsList;
    }

    // Export all filtered data to CSV
    function exportCSV() {
      const deviceId = getDeviceFilter();
      const evFilter = getEVFilter();
      let deviceIds = devices
        .filter(d => {
          if (deviceId && d.id !== deviceId) return false;
          if (evFilter === "ev" && d.fuelType !== "Electric") return false;
          if (evFilter === "ice" && d.fuelType === "Electric") return false;
          return true;
        }).map(d => d.id);

      let filteredBattery = batteryEvents.filter(e => deviceIds.includes(e.deviceId));
      let filteredCharging = chargingEvents.filter(e => deviceIds.includes(e.deviceId));
      let filteredFaults = faults.filter(f => deviceIds.includes(f.deviceId));
      let rows = [
        ['Type','Device','Lat','Lng','Time','Value','Description','Severity','Station']
      ];
      filteredBattery.forEach(e => rows.push(['Battery', e.device, e.lat, e.lng, e.time, e.level, e.low ? 'Low Battery' : '', '', '']));
      filteredCharging.forEach(e => rows.push(['Charge', e.device, e.lat, e.lng, e.time, '', '', '', e.station]));
      filteredFaults.forEach(f => rows.push(['Fault', f.device, f.lat, f.lng, f.time, f.code, f.description, f.severity, '']));
      let csv = rows.map(r => r.map(x => `"${x}"`).join(',')).join('\n');
      let a = document.createElement('a');
      a.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv);
      a.download = 'fw_heatmap_export.csv';
      a.click();
    }

    // Export map as image (stub; integrate leaflet-image or similar for full feature)
    function exportMapImage() {
      alert('Map export to image requires leaflet-image or similar. Integrate as needed.');
    }

    // UI event binding
    document.getElementById('exportBtn').onclick = exportCSV;
    document.getElementById('exportMapBtn').onclick = exportMapImage;
    document.getElementById('refreshBtn').onclick = authenticate;
    document.getElementById('deviceSelect').onchange = filterAndRender;
    document.getElementById('evFilter').onchange = filterAndRender;
    document.getElementById('dataType').onchange = filterAndRender;
    document.getElementById('startDate').onchange = authenticate;
    document.getElementById('endDate').onchange = authenticate;

    // Initial load
    authenticate();
  </script>
</body>
</html>
